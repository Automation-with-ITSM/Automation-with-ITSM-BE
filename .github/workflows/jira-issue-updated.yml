name: Update issue from Jira

on:
  repository_dispatch:
    types: [jira-issue-updated]

permissions:
  contents: read
  issues: write

jobs:
  update-issue:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Render via template and safe patch (with Jira fetch fallback)
        uses: actions/github-script@v7
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Node20ì€ global fetchê°€ ì¡´ì¬í•˜ë‹ˆ ë§Œì•½ ì—†ì„ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ì„œ require fallback
            const fetch = global.fetch || ((...args) => import('node-fetch').then(({default: f}) => f(...args)));

            const p   = context.payload.client_payload || {};
            const esc = (s) => (s ?? '').toString();
            const nz  = (s, f='') => { const v = esc(s).trim(); return v ? v : f; };
            const has = (s) => !!esc(s).trim();

            // urlEncoded(%)ì´ë©´ ë³µì› (+ â†’ ê³µë°±)
            const decodeMaybe = (s) => {
              const str = esc(s);
              try {
                const decoded = /%[0-9A-Fa-f]{2}/.test(str) ? decodeURIComponent(str) : str;
                return decoded.replace(/\+/g, ' ');
              } catch { return str; }
            };

            async function fetchJiraDescriptionHTML(issueKey) {
              const base = (process.env.JIRA_BASE_URL || process.env.JIRA_BASE || '').replace(/\/+$/,'');
              if (!base || !issueKey) return '';
              const url = `${base}/rest/api/3/issue/${encodeURIComponent(issueKey)}?expand=renderedFields&fields=description`;
              const resp = await fetch(url, {
                headers: {
                  'Accept': 'application/json',
                  'Authorization': 'Basic ' + Buffer.from(`${process.env.JIRA_USER_EMAIL}:${process.env.JIRA_API_TOKEN}`).toString('base64')
                }
              });
              if (!resp.ok) {
                core.info(`Jira GET failed: ${resp.status} ${await resp.text()}`);
                return '';
              }
              const data = await resp.json();
              return (data.renderedFields && data.renderedFields.description) ? data.renderedFields.description : '';
            }

            // ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ê¹ƒí—ˆë¸Œ ì²´í¬ë°•ìŠ¤ë¡œ ì •ê·œí™”
            function normalizeChecklist(input) {
              const raw = decodeMaybe(input);
              if (!has(raw)) return '';
              const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              return lines.map(line => {
                // ì´ë¯¸ - [ ] í˜•íƒœë©´ ìœ ì§€, ì•„ë‹ˆë¼ë©´ ë³€í™˜
                if (/^- \[.\] /.test(line)) return line;
                // Jiraì˜ [] ì ‘ë‘ ë“± ë‹¤ì–‘í•œ íŒ¨í„´ì„ - [ ] ë¡œ ë§¤í•‘
                if (/^\[\s?\]\s*/.test(line)) return line.replace(/^\[\s?\]\s*/, '- [ ] ');
                if (/^[\*\-]\s+/.test(line))   return line.replace(/^[\*\-]\s+/, '- [ ] ');
                return `- [ ] ${line}`;
              }).join('\n');
            }

            // 0) í•„ìˆ˜ê°’: Jiraì—ì„œì˜ "GitHub Issue Number"
            const issue_number = Number(p.issue_number);
            if (!issue_number) { core.setFailed('Missing issue_number in payload'); return; }

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // 1) í˜„ì¬ GitHub Issue ì½ê¸°(ë¹ˆê°’ ë®ì–´ì“°ê¸° ë°©ì§€)
            const cur = await github.rest.issues.get({ owner, repo, issue_number });
            const curTitle  = cur.data.title || '';
            const curBody   = cur.data.body  || '';
            const curLabels = (cur.data.labels || []).map(l => typeof l === 'string' ? l : l.name).filter(Boolean);

            // 2) kind ì •ê·œí™” (í•œê¸€/ì˜ë¬¸)
            const rawKind = esc(p.kind).toLowerCase();
            const isStory = /^(story|ìŠ¤í† ë¦¬)/.test(rawKind);
            const isBug   = /^(bug|ë²„ê·¸)/.test(rawKind);
            const kind    = isStory ? 'story' : (isBug ? 'bug' : 'task');

            // 3) í…œí”Œë¦¿ ì„ íƒ
            const mapping = {
              story: '.github/ISSUE_TEMPLATE/automation-story.md',
              bug:   '.github/ISSUE_TEMPLATE/automation-bug.md',
              task:  '.github/ISSUE_TEMPLATE/automation-task.md'
            };
            const file = mapping[kind] || mapping.task;
            const templatePath = path.join(process.cwd(), file);
            const hasTemplate = fs.existsSync(templatePath);
            const tpl = hasTemplate ? fs.readFileSync(templatePath, 'utf8') : '';

            // 4) ê°’ ì¤€ë¹„ + Jira ë³´ê°•
            const key         = esc(p.key);
            const urlLink     = esc(p.url);
            const summary     = esc(p.summary);
            let   description = esc(p.description);
            const priority    = esc(p.priority);
            const duedate     = nz(p.duedate, 'ë¯¸ì •');
            const checklistMD = normalizeChecklist(p.checklist);

            if (!description.trim() && key) {
              const html = await fetchJiraDescriptionHTML(key);
              if (has(html)) description = html;
            }

            // 5) í…œí”Œë¦¿ ë°”ì¸ë”©
            let producedBody = '';
            if (hasTemplate) {
              let body = tpl
                .replaceAll('{{issue.key}}', key)
                .replaceAll('{{key}}', key)
                .replaceAll('{{issue.url}}', urlLink)
                .replaceAll('{{url}}', urlLink)
                .replaceAll('{{issue.summary}}', summary)
                .replaceAll('{{summary}}', summary)
                .replaceAll('{{description}}', has(description) ? description : '')
                .replaceAll('{{priority}}', has(priority) ? priority : '')
                .replaceAll('{{issue.duedate}}', duedate)
                .replaceAll('{{duedate}}', duedate)
                .replaceAll('{{checklist}}', has(checklistMD) ? checklistMD : '');

              if (has(checklistMD) && !tpl.includes('{{checklist}}')) {
                body += `\n\n---\n\n### âœ… To-Do CheckList\n${checklistMD}\n`;
              }
              producedBody = body.trim();
            } else {
              const parts = [];
              if (has(description)) {
                parts.push('## ğŸ“„ ì´ìŠˆ ê°œìš” (Description)', description, ''); // HTML ê·¸ëŒ€ë¡œ
              }
              if (has(checklistMD)) {
                parts.push('---', '', '### âœ… To-Do CheckList', checklistMD, '');
              }
              if (has(priority)) {
                parts.push('---', '', '### ğŸ¯ ìš°ì„ ìˆœìœ„', `<ins>${priority}</ins>`, '');
              }
              if (has(duedate)) {
                parts.push('', '### ğŸ“… ê¸°í•œ', `*${duedate}*`, '');
              }
              if (has(key) || has(urlLink)) {
                const link = has(urlLink) ? `[**${key}**](${urlLink})` : key;
                parts.push('', '### ğŸ”— Jira Link', link);
              }
              producedBody = parts.join('\n').trim();
            }

            // 6) ë³¸ë¬¸ êµì²´ ì¡°ê±´ : ê°’ì´ ì˜¤ê±°ë‚˜ í˜„ì¬ ë¹„ì–´ìˆì„ ë•Œë§Œ êµì²´
            const shouldReplaceBody =
              has(description) || has(checklistMD) || has(priority) || has(duedate) || has(key) || has(urlLink) || !curBody;
            const nextBody = shouldReplaceBody ? (producedBody || curBody) : curBody;

            // 7) ì œëª© : ê°’ì´ ë¹„ë©´ ê¸°ì¡´ ìœ ì§€
            const nextTitle = (has(key) || has(summary))
              ? `[${nz(key, curTitle)}] ${nz(summary, curTitle)}`
              : curTitle;

            // 8) ë¼ë²¨ ê³„ì‚° (Story/Bug ê³ ì •, TaskëŠ” 3ì¢…ë§Œ) + (ë¹„ë©´ ê¸°ì¡´ ìœ ì§€)
            const allowed = new Set(['Feature','Refactor','Documentation','Story','Bug']);
            let computed = [];
            if (isStory) computed = ['Story'];
            else if (isBug) computed = ['Bug'];
            else {
              let incoming = [];
              if (Array.isArray(p.labels)) incoming = p.labels;
              else if (typeof p.labels === 'string') {
                try {
                  const parsed = JSON.parse(p.labels);
                  if (Array.isArray(parsed)) incoming = parsed;
                  else incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                } catch {
                  incoming = esc(p.labels).split(',').map(s=>s.trim()).filter(Boolean);
                }
              }
              const toTitle = s => s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s;
              computed = incoming.map(toTitle).filter(v => allowed.has(v) && v !== 'Story' && v !== 'Bug');
            }
            const setLabels = computed.length > 0; // ë¹„ë©´ ê¸°ì¡´ ë¼ë²¨ ìœ ì§€

            // 9) íŒ¨ì¹˜
            if (nextTitle !== curTitle || nextBody !== curBody) {
              await github.rest.issues.update({ owner, repo, issue_number, title: nextTitle, body: nextBody });
            }
            if (setLabels) {
              await github.rest.issues.setLabels({ owner, repo, issue_number, labels: computed });
            }

            core.info(`Patched #${issue_number} titleChanged=${nextTitle!==curTitle} bodyChanged=${nextBody!==curBody} labelsSet=${setLabels} kind=${kind} computed=${JSON.stringify(computed)}`)

      # Assignees ë§¤í•‘ ìŠ¤í… ì¶”ê°€
      - name: Assign mapped GitHub users
        uses: actions/github-script@v7
        env:
          JIRA_GIT_USER_MAPPING_JSON: ${{ secrets.JIRA_GIT_USER_MAPPING_JSON }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // payload / issue_number
            const p = context.payload.client_payload || {};
            const issue_number = Number(p.issue_number);
            if (!issue_number) {
              core.info('No issue_number in payload. Skip assigning.');
              return;
            }

            // 1) ë§¤í•‘ ë¡œë“œ : íŒŒì¼ ìš°ì„  â†’ ì‹œí¬ë¦¿ í´ë°±
            const mapPath = path.join(process.cwd(), '.github/jira-git-user-mapping.json');
            let raw = '';
            if (fs.existsSync(mapPath)) {
              raw = fs.readFileSync(mapPath, 'utf8');
              core.info(`Mapping file found at ${mapPath} (len=${raw.length})`);
            } else if (process.env.JIRA_GIT_USER_MAPPING_JSON) {
              raw = process.env.JIRA_GIT_USER_MAPPING_JSON;
              core.info(`Mapping loaded from secret JIRA_GIT_USER_MAPPING_JSON (len=${raw.length})`);
            } else {
              core.info('No mapping (file/secret). Skip assigning.');
              return;
            }

            // 1-1) BOM ì œê±° + íŒŒì‹± + í‚¤ ì†Œë¬¸ì ì •ê·œí™”
            let mapping = {};
            try {
              raw = raw.replace(/^\uFEFF/, '');
              const parsed = JSON.parse(raw);
              for (const [k, v] of Object.entries(parsed)) {
                mapping[String(k).toLowerCase()] = String(v);
              }
            } catch (e) {
              core.warning(`Failed to parse mapping JSON: ${e.message}`);
              return;
            }

            // 2) Jira payloadì—ì„œ ì‹ë³„ì ë½‘ê¸°
            //    ìš°ì„ ìˆœìœ„ : ì´ë©”ì¼ â†’ (ì˜µì…˜) accountId
            const email = (p.assigneeEmail || '').trim().toLowerCase();
            const accountId = (p.assigneeId || '').trim(); // í•„ìš”ì‹œ ë§¤í•‘ì— accountIdë„ ì¶”ê°€ ê°€ëŠ¥
            core.info(`assigneeEmail="${email || '(empty)'}" assigneeId="${accountId || '(empty)'}"`);

            // 3) ë§¤í•‘ ì¡°íšŒ
            const assignees = [];
            if (email && mapping[email]) assignees.push(mapping[email]);
            else if (accountId && mapping[accountId.toLowerCase?.() ?? accountId]) assignees.push(mapping[accountId.toLowerCase?.() ?? accountId]);

            if (assignees.length === 0) {
              core.info('No mapped assignees. Skip.');
              return;
            }

            // 4) GitHubì— ë°°ì • (ê¶Œí•œ ì—†ëŠ” ê³„ì •ì´ë©´ 422)
            try {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number,
                assignees
              });
              core.info(`Assigned: ${assignees.join(', ')}`);
            } catch (e) {
              core.warning(`Failed to add assignees: ${e.status} ${e.message}`);
            }
